#!/usr/bin/env python3
"""
Patch action type files to add ROS 2-style wrapper classes.
For actions like Fibonacci, this adds a top-level Fibonacci class that wraps
Fibonacci_Goal, Fibonacci_Result, etc.
"""
import os
import sys
import re

def patch_action_file(action_file):
    """
    Add ROS 2-style wrapper class to an action file.
    E.g., add 'class Fibonacci' that references Fibonacci_Goal, Fibonacci_Result, etc.
    """
    with open(action_file, 'r') as f:
        content = f.read()
    
    # Extract action name from file path
    # e.g., /path/to/example_interfaces/action/Fibonacci.py -> Fibonacci
    action_name = os.path.basename(action_file).replace('.py', '')
    
    # Check if wrapper class already exists
    if f'class {action_name}:' in content or f'class {action_name}(' in content:
        print(f"[SKIP] {action_file}: wrapper class already exists")
        return False
    
    # Check if required component classes exist
    goal_class = f'{action_name}_Goal'
    result_class = f'{action_name}_Result'
    feedback_class = f'{action_name}_Feedback'
    
    if not (f'class {goal_class}' in content):
        print(f"[SKIP] {action_file}: {goal_class} not found")
        return False
    
    # Detect package name from file path to make imports relative and generic
    # e.g., /path/to/example_interfaces/action/Fibonacci.py -> example_interfaces
    parts = action_file.split(os.sep)
    try:
        action_idx = parts.index('action')
        package_name = parts[action_idx - 1] if action_idx > 0 else 'unknown'
    except (ValueError, IndexError):
        package_name = 'unknown'
    
    # Create wrapper class with property-based proxy for Goal/Result/Feedback
    wrapper_code = f'''

# ROS 2-style action wrapper (auto-generated by patch_action_types.py)
# Note: All ROS 2 actions depend on action_msgs.srv.CancelGoal per ROS 2 specification

class _MessageProxy:
    """Proxy that converts attribute access to SWIG method calls for ROS 2 compatibility."""
    def __init__(self, swig_cls):
        object.__setattr__(self, '_swig_cls', swig_cls)
    
    def __call__(self, *args, **kwargs):
        instance = self._swig_cls(*args, **kwargs)
        return _MessageProxyInstance(instance)

class _MessageProxyInstance:
    """Instance proxy that wraps SWIG message instances for ROS 2-style attribute access."""
    def __init__(self, swig_instance):
        object.__setattr__(self, '_instance', swig_instance)
    
    def __getattribute__(self, name):
        if name == '_instance':
            return object.__getattribute__(self, '_instance')
        instance = object.__getattribute__(self, '_instance')
        # Try name first, then name_ (SWIG trailing underscore convention)
        try:
            attr = getattr(instance, name)
        except AttributeError:
            # SWIG may add trailing underscore for C++ member variables
            attr = getattr(instance, name + '_')
        # If it's a zero-arg callable (SWIG getter), call it
        if callable(attr):
            try:
                return attr()
            except TypeError:
                return attr
        return attr
    
    def __setattr__(self, name, value):
        instance = object.__getattribute__(self, '_instance')
        # Try name first, then name_ (SWIG trailing underscore convention)
        attr = None
        actual_name = name
        try:
            attr = getattr(instance, name, None)
        except Exception:
            pass
        if attr is None:
            try:
                attr = getattr(instance, name + '_', None)
                if attr is not None:
                    actual_name = name + '_'
            except Exception:
                pass
        # If attribute is a method, try calling it with the value (SWIG setter pattern)
        if callable(attr):
            try:
                attr(value)
                return
            except (TypeError, AttributeError):
                pass
        # For SWIG vectors, convert Python list to vector
        if isinstance(value, list) and attr is not None and hasattr(attr, 'append'):
            try:
                # Get the vector and clear it
                vec = attr() if callable(attr) else attr
                if hasattr(vec, 'clear'):
                    vec.clear()
                    for item in value:
                        vec.push_back(item)
                    return
            except Exception:
                pass
        # Fall back to direct attribute assignment
        try:
            setattr(instance, actual_name, value)
        except AttributeError:
            object.__setattr__(instance, actual_name, value)
    
    def __getattr__(self, name):
        instance = object.__getattribute__(self, '_instance')
        return getattr(instance, name)
    
    # Return the wrapped SWIG instance to support passing to C++ code
    def __repr__(self):
        return repr(object.__getattribute__(self, '_instance'))
    
    def __str__(self):
        return str(object.__getattribute__(self, '_instance'))

class {action_name}:
    """ROS 2-style action type for {action_name} (package: {package_name})."""
    Goal = _MessageProxy({goal_class})
    Result = _MessageProxy({result_class})
    Feedback = _MessageProxy({feedback_class})
    
    # SendGoal service
    class SendGoal:
        Request = {action_name}_SendGoal_Request
        Response = {action_name}_SendGoal_Response
    
    # GetResult service
    class GetResult:
        Request = {action_name}_GetResult_Request
        Response = {action_name}_GetResult_Response
    
    FeedbackMessage = {action_name}_FeedbackMessage
    
    # CancelGoal service (standardized across all ROS 2 actions via action_msgs)
    # Import with fallback to handle missing dependencies gracefully
    try:
        from action_msgs.srv import CancelGoal as _CancelGoal
        CancelGoal = _CancelGoal
    except ImportError:
        # If action_msgs is not available, CancelGoal will be None
        # This allows the action type to load, but cancel functionality will be unavailable
        CancelGoal = None
'''
    
    # Append to file
    with open(action_file, 'a') as f:
        f.write(wrapper_code)
    
    print(f"[PATCHED] {action_file}: added {action_name} wrapper class")
    return True

def main():
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <root_dir>")
        print(f"  Patches all action .py files under <root_dir>/**/action/")
        sys.exit(1)
    
    root_dir = sys.argv[1]
    if not os.path.isdir(root_dir):
        print(f"Error: {root_dir} is not a directory")
        sys.exit(1)
    
    patched_count = 0
    
    # Find all action directories
    for dirpath, dirnames, filenames in os.walk(root_dir):
        if not dirpath.endswith('/action'):
            continue
        
        # Find action .py files (not _*Wrapper.py, not __init__.py)
        for filename in filenames:
            if not filename.endswith('.py'):
                continue
            if filename.startswith('_') or filename.startswith('lib') or filename == '__init__.py':
                continue
            
            action_file = os.path.join(dirpath, filename)
            if patch_action_file(action_file):
                patched_count += 1
    
    print(f"\n[DONE] Patched {patched_count} action files")
    return 0 if patched_count > 0 else 1

if __name__ == '__main__':
    sys.exit(main())
